from Crypto.Util.number import *

#invmod 扩展欧几里得算法
def invmod(a, b):
    if a == 0:
        return b, 0, 1
    gcd, x1, y1 = invmod(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd, x, y
def encrypt(m, e, n):
	return pow(m, e, n)
def decrypt(c, d, n):
	return pow(c, d, n)
# 生成公钥私钥
# p = getPrime(1024)
# q = getPrime(1024)
p = 144657838765078425703164806457216921477093374663118479070673261913719681718312177396156059538672930552709406524162210294003788503577929085700335797117548366618878583462002071304643677618046739139194632121354869197731661449634548311809777496012183687152603515305881790121976301114465584402957004451930326759449
q = 130151079321738715375389408801118083070659761195908790352188077143369611581496388807313696732361378824918070549446192627854870086449688151141029898467020994320058325121120672825791061640272288917136099641104341407819887215949962012934180137944871450069503315443178886816862307361411270861966444531236874455461
n = p * q
et = (p - 1) * (q - 1)
e = 3
d = invmod(e, et)[1]

#数字测试
c_42 = encrypt(42, e, n)
print(f"p={p},q={q}")
print(f"对42加密={c_42},解密={decrypt(c_42, d, n)}")
b = getPrime(1000)
print(b)
c_p = encrypt(b,e,n)
print(f"对p加密={c_p},解密={decrypt(c_p, d, n)}")

#字符串测试
s = b"flag{dyt_22049200180_EXP3_rsa}"
plaintext = bytes_to_long(s)
ciphertext = encrypt(plaintext, e, n)
print(ciphertext)
m = decrypt(ciphertext, d, n)
print(long_to_bytes(m))




